<?xml version='1.0' encoding='UTF-8' standalone='no'?><ResultsSession buildId="CLI-DEMO1-2025-07-17" date="07/17/25 11:14:05" endTime="1970-01-01T03:00:00+03:00" machine="ESL1" project="CLI-DEMO1" tag="Flow Analysis Standard_Thorough" time="2025-07-17T11:14:05+03:00" toolName="C++test" toolVer="2025.1.0.20250523B2782" user="danie">
   <TestParameters cmdLn="C++test: -config c++test.user://Flow Analysis Standard_Thorough "/>
   <TestConfig machine="ESL1" name="Flow Analysis Standard_Thorough" pseudoUrl="c++test.user://Flow Analysis Standard_Thorough" user="danie"/>
   <Authors>
      <Author id="dev1" name="danie"/>
   </Authors>
   <VersionInfos>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.execution" resultId="IExecutionViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.execution" resultId="InsureViolation" ver="3"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.scope" resultId="IScopeProjectInfo" ver="3"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IMetricsViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IDupCodeViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IFlowAnalysisViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="ICodingStandardsViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.generation" resultId="IGenerationInfo" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.generation" resultId="IGenerationProjectInfo" ver="2"/>
   </VersionInfos>
   
      <Locations>
      <Loc fsPath="C:\Parasoft\Elbit_CLI\hello_world_solution\hello_world_solution\hello_world_solution.cpp" loc="hello_world_solution/hello_world_solution/hello_world_solution.cpp" projPath="hello_world_solution/hello_world_solution" project="hello_world_solution"/>
   </Locations>
   
   
   <Scope>
      <ProjectInformations>
         <ScopeProjectInfo fltFiles="1" fltLns="82" project="hello_world_solution/hello_world_solution" totFiles="1" totLns="82"/>
      </ProjectInformations>
   </Scope>
   <CodingStandards ownerId="com.parasoft.xtest.checkers.api.standards" time="0:00:27">
      <Projects>
         <Project bdCheckedFiles="1" bdTotalFiles="1" checkedFiles="1" checkedLns="82" name="hello_world_solution" qfixErrs="0" suppErrs="0" totErrs="9" totFiles="1" totLns="82"/>
      </Projects>
      <TestingProcessProblems>
         <StaticAnalyzerTestingProcessProblem tested="[WARNING] Validation problems with rule mapping/cloning:">
            <ErrorList>
               <Error val="The rule ID JSF-001 used for mapping or cloning of the METRICS-25 rule already exists in the system."/>
               <Error val="The rule ID JSF-003 used for mapping or cloning of the METRICS-28 rule already exists in the system."/>
               <Error val="The rule ID JSF-003_b used for mapping or cloning of the METRICS-42 rule already exists in the system."/>
               <Error val="The rule ID JSF-009 used for mapping or cloning of the MISRA-005 rule already exists in the system."/>
               <Error val="The rule ID JSF-010 used for mapping or cloning of the MISRA-006 rule already exists in the system."/>
               <Error val="The rule ID JSF-011 used for mapping or cloning of the MISRA2004-4_2 rule already exists in the system."/>
               <Error val="The rule ID JSF-012 used for mapping or cloning of the CODSTA-48 rule already exists in the system."/>
               <Error val="The rule ID JSF-013 used for mapping or cloning of the MISRA-008 rule already exists in the system."/>
               <Error val="The rule ID JSF-014 used for mapping or cloning of the PORT-01 rule already exists in the system."/>
               <Error val="The rule ID JSF-015 used for mapping or cloning of the MISRA-004_a rule already exists in the system."/>
            </ErrorList>
         </StaticAnalyzerTestingProcessProblem>
      </TestingProcessProblems>
      <Rules>
         <RulesList>
            <Rule cat="BD-API" desc="Do not pass incorrect values to library functions" id="BD-API-BADPARAM" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="Do not pass negative values to functions expecting non-negative arguments" id="BD-API-NEGPARAM" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="Do not pass incorrect values to ctype.h library functions" id="BD-API-CTYPE" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="Do not pass 0 value as a size argument to the realloc function" id="BD-API-REALLOC" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="Do not check for a non-negative value after passing as a non-negative argument" id="BD-API-REVNEGPARAM" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="The size_t argument passed to any function in string.h shall have an appropriate value" id="BD-API-STRSIZE" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="Validate values passed to library functions" id="BD-API-VALPARAM" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-CO" desc="Do not access iterator out of range" id="BD-CO-ITOUT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-CO" desc="Use valid references, pointers, and iterators to reference elements of a basic_string" id="BD-CO-STRMOD" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-CO" desc="Do not pass empty container iterators to std algorithms as destinations" id="BD-CO-EMPCON" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-CO" desc="Do not compare iterators from different containers" id="BD-CO-ITINVCOMP" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-CO" desc="Do not modify container while iterating over it" id="BD-CO-ITMOD" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-MISC" desc="Always close transactions" id="BD-MISC-TRANS" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-MISC" desc="Prevent calling unsafe functions (custom rule)" id="BD-MISC-DC" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Always catch exceptions" id="BD-PB-EXCEPT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid signed integer overflows" id="BD-PB-INTUB" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not modify string literals" id="BD-PB-MODSTR" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not read the value of a non-active union field" id="BD-PB-NAUNF" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid use before initialization" id="BD-PB-NOTINIT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Atomic objects shall be properly initialized before being accessed" id="BD-PB-NOTINITAT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid null pointer dereferencing" id="BD-PB-NP" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid buffer overflow due to defining incorrect format limits" id="BD-PB-OVERFFMT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid overflow due to reading a not zero terminated string" id="BD-PB-OVERFNZT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid overflow when reading from a buffer" id="BD-PB-OVERFRD" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid overflow when writing to a buffer" id="BD-PB-OVERFWR" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not point to a wrapped object that has been freed" id="BD-PB-WRAPESC" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid division by zero" id="BD-PB-ZERO" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid accessing arrays out of bounds" id="BD-PB-ARRAY" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="A pointer pointing to an element of an array of objects shall not be passed to a smart pointer of single object type" id="BD-PB-ARRPTR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid incorrect shift operations" id="BD-PB-BADSHIFT" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Use the correct byte ordering when transferring data between systems" id="BD-PB-BYTEORD" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid conditions that always evaluate to the same value" id="BD-PB-CC" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="BD-PB" desc="Consistently check the returned value of non-void functions" id="BD-PB-CHECKRET" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Always check the returned value of non-void function" id="BD-PB-CHECKRETGEN" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid accessing collections out of bounds" id="BD-PB-COOB" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not modify the alignment of objects by calling realloc()" id="BD-PB-DNMPTR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="The macro EOF should be compared with the unmodified return value from the Standard Library function" id="BD-PB-EOFCOMP" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Properly use errno value" id="BD-PB-ERRNO" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Properly define exit handlers" id="BD-PB-EXITHAN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Reset strings on fgets() or fgetws() failure" id="BD-PB-FGETS" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Only use values for fsetpos() that are returned from fgetpos()" id="BD-PB-FSETPOS" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid infinite recursion" id="BD-PB-INFREC" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid data loss when converting between integer types" id="BD-PB-INTDL" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not rely on an environment pointer following an operation that may invalidate it" id="BD-PB-INVENV" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Pointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function" id="BD-PB-INVRET" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not use an object after its lifetime has ended" id="BD-PB-LIFETIME" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="The Standard Library function memcmp shall not be used to compare null terminated strings" id="BD-PB-MCCSTR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid calls to memory-setting functions that can be optimized out by the compiler" id="BD-PB-MEMOPT" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Properly define new handlers" id="BD-PB-NEWHAN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid throwing exceptions from functions that are declared not to throw" id="BD-PB-NOEXCEPT" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Declare non-returning functions with the attribute that specifies that they do not return" id="BD-PB-NORETDECL" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Never return from functions that should not return" id="BD-PB-NORETURN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid accessing arrays and pointers out of bounds" id="BD-PB-OVERFARRAY" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="An object shall not be assigned or copied to an overlapping object" id="BD-PB-OVERLAP" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not treat arrays polymorphically" id="BD-PB-POLARR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="BD-PB-PTRARR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not compare two unrelated pointers" id="BD-PB-PTRCMP" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not subtract two pointers that do not address elements of the same array" id="BD-PB-PTRSUB" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not store an already-owned pointer value in an unrelated smart pointer" id="BD-PB-PTRVALUE" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not call putenv() with a pointer to an automatic variable as the argument" id="BD-PB-PUTENV" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Properly define signal handlers" id="BD-PB-SIGHAN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not return from a computational exception signal handler" id="BD-PB-SIGRETURN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not alternately input and output from a stream without an intervening flush or positioning call" id="BD-PB-STREAMINOUT" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not subsequently use the argument to std::forward" id="BD-PB-SUBSEQFRWD" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not rely on the value of a moved-from object" id="BD-PB-SUBSEQMOVE" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid switch with unreachable branches" id="BD-PB-SWITCH" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Properly define terminate handlers" id="BD-PB-TERMHAN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Properly define unexpected handlers" id="BD-PB-UNEXPHAN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not use the ungetc function on a stream with the file position indicator zero" id="BD-PB-UNGETC" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not use dynamic type of an object under construction" id="BD-PB-VCTOR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not use dynamic type of an object under destruction" id="BD-PB-VDTOR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Ensure the size of the variable length array is in valid range" id="BD-PB-VLASIZE" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="The same file shall not be opened for read and write access at the same time on different streams" id="BD-PB-WRRDSTR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid writing to a stream which has been opened as read only" id="BD-PB-WRROS" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid value change when converting between integer types" id="BD-PB-INTVC" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid wraparounds when performing arithmetic integer operations" id="BD-PB-INTWRAP" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Ensure strings are zero terminated" id="BD-PB-NZTS" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Ensure the output buffer is large enough when using path manipulation functions" id="BD-PB-PATHBUF" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="A parameter shall be passed by reference if it can't be NULL" id="BD-PB-REFPARAM" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Always throw the created std::exception object" id="BD-PB-STDEXC" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Suspicious setting of stream flags" id="BD-PB-STREAMFLAGS" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Restore stream format" id="BD-PB-STREAMFMT" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Use macros for variable arguments correctly" id="BD-PB-VARARGS" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid unused values" id="BD-PB-VOVR" sev="3">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid unreachable methods" id="BD-PB-UCMETH" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Guarantee that container indices are within the valid range" id="BD-PB-VALRANGE" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not use floating-point expressions which may result in NaN and infinity values" id="BD-PB-NANINF" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not use recursion" id="BD-PB-RECFUN" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Properly deallocate dynamically allocated resources" id="BD-RES-BADDEALLOC" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Ensure deallocation functions guarantee resource freeing" id="BD-RES-BADFREEF" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Do not use resources that have been freed" id="BD-RES-FREE" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Allocate sufficient memory to hold an object of a given type" id="BD-RES-INSUFMEM" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Do not free resources using invalid pointers" id="BD-RES-INVFREE" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Ensure resources are freed" id="BD-RES-LEAKS" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Avoid cyclic shared_ptr references" id="BD-RES-CSP" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Do not create variables on the stack above the defined limits" id="BD-RES-STACKLIM" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid tainted data in array indexes" id="BD-SECURITY-ARRAY" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Prevent buffer overflows from tainted data" id="BD-SECURITY-BUFWRITE" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid unsafe use of a value obtained from arithmetic operations on tainted value" id="BD-SECURITY-INTOVERF" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="BD-SECURITY-OVERFFMT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid buffer read overflow from tainted data" id="BD-SECURITY-OVERFRD" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid buffer write overflow from tainted data" id="BD-SECURITY-OVERFWR" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Protect against command injection" id="BD-SECURITY-TDCMD" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid printing tainted data on the output console" id="BD-SECURITY-TDCONSOLE" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Protect against environment injection" id="BD-SECURITY-TDENV" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Protect against file name injection" id="BD-SECURITY-TDFNAMES" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Exclude unsanitized user input from format strings" id="BD-SECURITY-TDINPUT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid potential integer overflow/underflow on tainted data" id="BD-SECURITY-TDINTOVERF" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Validate potentially tainted data before it is used in the controlling expression of a loop" id="BD-SECURITY-TDLOOP" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Protect against SQL injection" id="BD-SECURITY-TDSQL" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid passing unvalidated binary data to log methods" id="BD-SECURITY-LOG" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Properly seed pseudorandom number generators" id="BD-SECURITY-RAND" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Sensitive data should be cleared before being deallocated" id="BD-SECURITY-SENSFREE" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid passing sensitive data to functions that write to log files" id="BD-SECURITY-SENSLOG" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Validate potentially tainted data before it is used to determine the size of memory allocation" id="BD-SECURITY-TDALLOC" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="BD-SECURITY-XXEXRC" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Avoid double locking" id="BD-TRS-DLOCK" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Avoid race conditions when using fork and file descriptors" id="BD-TRS-FORKFILE" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not abandon unreleased locks" id="BD-TRS-LOCK" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not use global variable with different locks set" id="BD-TRS-MLOCK" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not acquire locks in different order" id="BD-TRS-ORDER" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Avoid race conditions while checking for the existence of a symbolic link" id="BD-TRS-SYMLINK" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not use blocking functions while holding a lock" id="BD-TRS-TSHL" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Declare objects shared between POSIX threads with appropriate storage durations" id="BD-TRS-ARG" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Make const member functions thread-safe" id="BD-TRS-CMF" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Variable should be used in context of single critical section" id="BD-TRS-DIFCS" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Avoid race conditions while accessing files" id="BD-TRS-FRC" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not join or detach a thread that was previously joined or detached" id="BD-TRS-JOINDETACH" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="The Standard Library function mtx_timedlock() shall not be invoked on a mutex that does not support timeout" id="BD-TRS-TIMEDLOCK" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Use locks to prevent race conditions when modifying bit fields" id="BD-TRS-BITLOCK" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not destroy another thread's mutex" id="BD-TRS-DSTRLOCK" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not release a lock that has not been acquired" id="BD-TRS-REVLOCK" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="There shall be no data races between threads" id="BD-TRS-THRDR" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="A thread synchronization object should not be destroyed by a thread" id="BD-TRS-THRDSTR" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="A thread synchronization object should not be initialized by a thread" id="BD-TRS-THRINIT" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="A thread should not be created by another thread" id="BD-TRS-THRTHR" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="A thread-specific storage should not be created by a thread" id="BD-TRS-THRTSS" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
         </RulesList>
         <CategoriesList>
            <Category desc="Flow Analysis" name="BD" total="137">
               <Category desc="Incorrect API usage" name="BD-API" total="7">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Miscellaneous" name="BD-MISC" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Possible Bugs" name="BD-PB" total="74">
                  <Stats authTot="9;" total="9"/>
               </Category>
               <Category desc="Resources" name="BD-RES" total="8">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Security" name="BD-SECURITY" total="20">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Containers" name="BD-CO" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Threads &amp; Synchronization" name="BD-TRS" total="21">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
         </CategoriesList>
         <SeverityList>
            <Severity id="1">
               <Stats authTot="1;" total="1"/>
            </Severity>
            <Severity id="2">
               <Stats authTot="2;" total="2"/>
            </Severity>
            <Severity id="3">
               <Stats authTot="6;" total="6"/>
            </Severity>
         </SeverityList>
      </Rules>
      
  <StdViols>
    <FlowViol msg="&quot;ptr&quot; may possibly be null" ln="24" ruleSAFMsg="Null pointer dereferencing point" auth="danie" sev="1" rule="BD-PB-NP" ruleSCSCMsg="Source of null value" tool="c++test" id="-467176186" lang="cpp" locType="sr" config="2" hash="1054993809" locStartln="24" locStartPos="0" locEndLn="25" locEndPos="0" locFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" FirstElSrcRngStartln="17" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="18" FirstElSrcRngEndPos="0" FirstElSrcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp">
      <ElDescList>
        <ElDesc srcRngStartln="17" srcRngStartPos="0" srcRngEndLn="18" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="17" ElType=".C" desc="malloc(...)" rngLn="17">
          <Anns>
            <Ann msg="Source of null value" kind="cause"/>
            <Ann msg="Null value carrier: malloc(...)" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="17" srcRngStartPos="0" srcRngEndLn="18" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="17" ElType="!" desc="int* ptr = (int*)malloc(sizeof(int) * 10);" rngLn="17">
          <Anns>
            <Ann msg="Null value carrier: malloc(...) -> ptr" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="23" srcRngStartPos="0" srcRngEndLn="24" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="23" ElType="." desc="int uninitialized_var = 0; // Initialize to avoid compile error but still a violation" rngLn="23"/>
        <ElDesc srcRngStartln="24" srcRngStartPos="0" srcRngEndLn="25" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="24" ElType=".P" desc="*ptr = uninitialized_var;" rngLn="24">
          <Anns>
            <Ann msg="Null value carrier: ptr" kind="comment"/>
            <Ann msg="Null pointer dereferencing point" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value returned from method &quot;malloc&quot; should be checked" ln="27" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="2" rule="BD-PB-CHECKRETGEN" ruleSCSCMsg="Method call" tool="c++test" id="2015139356" lang="cpp" locType="sr" config="2" hash="1054993809" locStartln="27" locStartPos="0" locEndLn="28" locEndPos="0" locFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" FirstElSrcRngStartln="17" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="18" FirstElSrcRngEndPos="0" FirstElSrcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp">
      <ElDescList>
        <ElDesc srcRngStartln="17" srcRngStartPos="0" srcRngEndLn="18" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="17" ElType=".C" desc="malloc(...)" rngLn="17">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="17" srcRngStartPos="0" srcRngEndLn="18" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="17" ElType="." desc="int* ptr = (int*)malloc(sizeof(int) * 10);" rngLn="17"/>
        <ElDesc srcRngStartln="23" srcRngStartPos="0" srcRngEndLn="24" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="23" ElType="." desc="int uninitialized_var = 0; // Initialize to avoid compile error but still a violation" rngLn="23"/>
        <ElDesc srcRngStartln="24" srcRngStartPos="0" srcRngEndLn="25" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="24" ElType="." desc="*ptr = uninitialized_var;" rngLn="24"/>
        <ElDesc srcRngStartln="27" srcRngStartPos="0" srcRngEndLn="28" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="27" ElType=".P" desc="free(ptr);" rngLn="27">
          <Anns>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Value of &quot;array&quot; is never used" ln="44" sev="3" auth="danie" rule="BD-PB-VOVR" tool="c++test" cat="BD-PB" lang="cpp" locType="sr" config="2" hash="1054993809" locStartln="44" locStartPos="0" locEndLn="45" locEndPos="0" locFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp"/>
    <StdViol msg="Value of &quot;octal_number&quot; is never used" ln="53" sev="3" auth="danie" rule="BD-PB-VOVR" tool="c++test" cat="BD-PB" lang="cpp" locType="sr" config="2" hash="1054993809" locStartln="53" locStartPos="0" locEndLn="54" locEndPos="0" locFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp"/>
    <StdViol msg="Value of &quot;unused_variable&quot; is never used" ln="56" sev="3" auth="danie" rule="BD-PB-VOVR" tool="c++test" cat="BD-PB" lang="cpp" locType="sr" config="2" hash="1054993809" locStartln="56" locStartPos="0" locEndLn="57" locEndPos="0" locFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp"/>
    <FlowViol msg="Condition &quot;x != 0&quot; always evaluates to true" ln="59" ruleSAFMsg="Point where senseless condition is used" auth="danie" sev="2" rule="BD-PB-CC" ruleSCSCMsg="Start of the path" tool="c++test" id="-1420781954" lang="cpp" locType="sr" config="2" hash="1054993809" locStartln="59" locStartPos="0" locEndLn="60" locEndPos="0" locFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" FirstElSrcRngStartln="30" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="31" FirstElSrcRngEndPos="0" FirstElSrcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp">
      <ElDescList>
        <ElDesc srcRngStartln="30" srcRngStartPos="0" srcRngEndLn="31" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="30" ElType=".C" desc="int main()" rngLn="30">
          <Anns>
            <Ann msg="Start of the path" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="32" srcRngStartPos="0" srcRngEndLn="33" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="32" ElType="." desc="std::cout &lt;&lt; &quot;Hello World!\n&quot;;" rngLn="32"/>
        <ElDesc srcRngStartln="35" srcRngStartPos="0" srcRngEndLn="36" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="35" ElType="." desc="volatile uint64_t counter = 0;" rngLn="35"/>
        <ElDesc srcRngStartln="36" srcRngStartPos="0" srcRngEndLn="37" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="36" ElType="." desc="volatile double number = 123.456789;" rngLn="36"/>
        <ElDesc srcRngStartln="37" srcRngStartPos="0" srcRngEndLn="38" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="37" ElType="." desc="counter = static_cast&lt;uint64_t>(number); // Fix compile error but still a MISRA violation for implicit conversion" rngLn="37"/>
        <ElDesc srcRngStartln="40" srcRngStartPos="0" srcRngEndLn="41" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="40" ElType="." desc="int octal_number;" rngLn="40"/>
        <ElDesc srcRngStartln="41" srcRngStartPos="0" srcRngEndLn="42" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="41" ElType="." desc="int unused_variable;" rngLn="41"/>
        <ElDesc srcRngStartln="42" srcRngStartPos="0" srcRngEndLn="43" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="42" ElType="." desc="int x;" rngLn="42"/>
        <ElDesc srcRngStartln="43" srcRngStartPos="0" srcRngEndLn="44" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="43" ElType="." desc="int a, b;" rngLn="43"/>
        <ElDesc srcRngStartln="44" srcRngStartPos="0" srcRngEndLn="45" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="44" ElType="." desc="int array[MAX_SIZE]; // MISRA violation: non-const array size" rngLn="44"/>
        <ElDesc srcRngStartln="45" srcRngStartPos="0" srcRngEndLn="46" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="45" ElType="." desc="const char* c_string; // Fix const qualifier issue" rngLn="45"/>
        <ElDesc srcRngStartln="46" srcRngStartPos="0" srcRngEndLn="47" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="46" ElType="." desc="char buffer[50]; // Make buffer larger to avoid overflow" rngLn="46"/>
        <ElDesc srcRngStartln="49" srcRngStartPos="0" srcRngEndLn="50" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="49" ElType="." desc="if (counter > 50)" rngLn="49">
          <Anns>
            <Ann msg="Condition evaluation: (counter > 50) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="53" srcRngStartPos="0" srcRngEndLn="54" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="53" ElType="." desc="octal_number = 0777;" rngLn="53"/>
        <ElDesc srcRngStartln="56" srcRngStartPos="0" srcRngEndLn="57" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="56" ElType="." desc="unused_variable = 42;" rngLn="56"/>
        <ElDesc srcRngStartln="59" srcRngStartPos="0" srcRngEndLn="60" srcRngEndPos="0" srcRngFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp" srcRnghash="1054993809" ln="59" ElType=".P" desc="if ((x = 5) != 0) { // Fix syntax but keep the violation" rngLn="59">
          <Anns>
            <Ann msg="Point where senseless condition is used" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Value of &quot;a&quot; is never used" ln="64" sev="3" auth="danie" rule="BD-PB-VOVR" tool="c++test" cat="BD-PB" lang="cpp" locType="sr" config="2" hash="1054993809" locStartln="64" locStartPos="0" locEndLn="65" locEndPos="0" locFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp"/>
    <StdViol msg="Value of &quot;b&quot; is never used" ln="64" sev="3" auth="danie" rule="BD-PB-VOVR" tool="c++test" cat="BD-PB" lang="cpp" locType="sr" config="2" hash="1054993809" locStartln="64" locStartPos="0" locEndLn="65" locEndPos="0" locFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp"/>
    <StdViol msg="Value of &quot;c_string&quot; is never used" ln="67" sev="3" auth="danie" rule="BD-PB-VOVR" tool="c++test" cat="BD-PB" lang="cpp" locType="sr" config="2" hash="1054993809" locStartln="67" locStartPos="0" locEndLn="68" locEndPos="0" locFile="hello_world_solution/hello_world_solution/hello_world_solution.cpp"/>
  </StdViols>

      <Supps/>
      
      <TestedFilesDetails>
         <Total name="Suppressed / Total" supp="0" total="9">
            <Project name="hello_world_solution" supp="0" total="9">
               <Res loc="hello_world_solution/hello_world_solution/hello_world_solution.cpp" locType="sr" name="hello_world_solution.cpp" supp="0" total="9"/>
            </Project>
         </Total>
      </TestedFilesDetails>
   
   </CodingStandards>
   <AssocUrls/>
</ResultsSession>